---
title: 'Lab: Streaming Data Pipeline'
description: 'Build a streaming data pipeline using Kafka, Spark Streaming, Cassandra, and MySQL'
icon: flask
---

## Pre-Lab Preparation & Prerequisites
<CardGroup cols={2}>
  <Card icon="gears" title="Docker" href="https://docs.docker.com/get-started/get-docker/">
    Install Docker on your machine, follow the guides depending on the OS your device is running.
  </Card>
  <Card icon="youtube" title="Docker Fundamentals" href="https://youtu.be/ZlLwDN9_Gwg?si=7J0cZzeRMvLkfNYU">
    You will need to have a basic understanding of Docker, especially on Docker Compose.
  </Card>
  <Card icon="key" title="Introduction to NoSQL" href="/kafka-redis/nosql">
    Review the module to familiarize yourself with the NoSQL paradigm.
  </Card>
  <Card icon="key" title="Introduction to Kafka" href="/kafka-redis/kafka">
    Review the module to understand the key concepts of Kafka as a data streaming tool.
  </Card>
</CardGroup>

## Overview
In the previous section, we have learned the theoretical concept of Apache Kafka and its role in real time data streaming. 
You will put the theory into practice in this lab, where we will explore the power of open-source technologies (Kafka, Spark Structured Streaming, Cassandra and MySQL) 
to build a robust and scalable streaming data processing pipeline. We will begin by producing simulated raw stock price data using a producer and sending it to Kafka. 
Leveraging the microbatch processing capabilities of [Spark Structured Streaming](https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html), we will load the raw data into [Cassandra](https://cassandra.apache.org/_/index.html), a distributed NoSQL database, for real-time transaction processing (OLTP). 
Simultaneously, we will aggregate the data and store it in [MySQL](https://www.mysql.com/), a relational database, for analytical processing (OLAP). 
To bring the insights to life, we will then visualize the aggregated data in the form of a dynamic dashboard using [Streamlit](https://streamlit.io/), an open-source Python library to build custom web apps. 
This comprehensive architecture allows organizations to extract (near) real-time insights from streaming data, enabling informed decision-making and improved business performance.

## Project Environment
To start the project, we will create a new directory named `streaming_data_processing` or any name you would like to identify the project as. 
Next, make a new file named `docker-compose.yml` in the project directory and copy the following into the file:

```yaml docker-compose.yml
version: '1'

services:
  zookeeper:
    image: bitnami/zookeeper:3.9.2
    container_name: zookeeper
    ports:
      - "2181:2181"
    environment:
      - ALLOW_ANONYMOUS_LOGIN=yes
    volumes:
      - zookeeper-data:/bitnami/zookeeper

  kafka:
    image: bitnami/kafka:3.5.2
    container_name: kafka
    ports:
      - "29092:29092"
    environment:
      - ALLOW_PLAINTEXT_LISTENER=yes
      - KAFKA_ENABLE_KRAFT=no
      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181
      - KAFKA_CFG_LISTENERS=INTERNAL://:9092,EXTERNAL://:29092
      - KAFKA_CFG_ADVERTISED_LISTENERS=INTERNAL://kafka:9092,EXTERNAL://localhost:29092
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT
      - KAFKA_INTER_BROKER_LISTENER_NAME=INTERNAL

    volumes:
      - kafka-data:/bitnami/kafka
    depends_on:
      - zookeeper
    restart: always

  spark:
    image: bitnami/spark:3.5.2
    container_name: spark
    environment:
      - SPARK_MODE=master
    ports:
      - "8080:8080"
      - "4040:4040"
    volumes:
      - ./spark_script:/spark_script
      - ./spark-defaults.conf:/opt/bitnami/spark/conf/spark-defaults.conf
    depends_on:
      - zookeeper
      - kafka
      - cassandra
    command: bash -c "python -m pip install py4j==0.10.9.7 && tail -f /dev/null"

  spark-worker:
    image: docker.io/bitnami/spark:3.5.2
    container_name: spark-worker
    environment:
      - SPARK_MODE=worker
      - SPARK_MASTER_URL=spark://spark:7077
      - SPARK_WORKER_MEMORY=1G
      - SPARK_WORKER_CORES=1
    ports:
      - "8081:8081"
    volumes:
      - ./spark-defaults.conf:/opt/bitnami/spark/conf/spark-defaults.conf
    depends_on:
      - zookeeper
      - kafka
      - cassandra
    command: bash -c "python -m pip install py4j==0.10.9.7 && tail -f /dev/null"

  cassandra:
    image: cassandra:5.0
    container_name: cassandra
    ports:
      - "9042:9042"
    volumes:
      - cassandra-data:/var/lib/cassandra

  mysql:
    image: mysql:9.0.1
    container_name: mysql
    ports:
      - "3307:3306"
    environment:
      MYSQL_ROOT_PASSWORD: root
    volumes:
      - mysql-data:/var/lib/mysql

volumes:
  zookeeper-data:
  kafka-data:
  cassandra-data:
  mysql-data:
```
Don't feel intimidated with the contents of the Docker Compose file. We will go through each of the services in the next section.

Next, we will create a new file named `spark-defaults.conf` in the project directory, which contains the Spark application configuration properties. We will populate the file later, so for now we can leave it empty.

Last, we will create a new folder `spark_script` in the project directory, which will be used to store the Spark application script. For now, we can leave the folder empty.

After you have completed through all the steps, the project structure will now look like this:

```tree
streaming_data_processing
├── docker-compose.yml
├── spark-defaults.conf
└── spark_script
```

## Understanding Docker
The `docker-compose.yml` file include seven services: `zookeeper`, `kafka`, `spark`, `spark-worker`, `cassandra`, and `mysql`. 
For each service, we define the service name and other configurations such as `image`, `container_name`, `ports`, `environment`, `volumes`, `depends_on`, `restart`, and `command`. 
Below is a brief description of each configuration.

* **service name** is used to identify and reference a specific service within the Docker Compose file.
* **image** configuration specifies the Docker image to be used for the service which will be pulled from Docker Hub.
* **container_name** configuration allows us to assign a custom name to the container created from the image. Although it doesn’t have to match the service name, it is recommended to keep them consistent.
* **ports** configuration defines the port mappings between the host machine and the container. It allows us to access services running inside the container from the host using specified ports.
* **environment** configuration is used to set environment variables specific to the container.
* **volumes** configuration is used to mount either Docker volumes or bind mounts inside the container. Docker volumes provide a means to persist data generated by the container by creating and managing storage entities that are independent of the host’s filesystem. On the other hand, bind mounts establish a direct mapping between a directory on the host and a directory inside the container. This allows us to retain data even after the container is removed.
* **depends_on** configuration specifies the service that the current service depends on, which ensures that the current service will not start until all the dependencies are started.
* **restart** configuration determines the restart policy for a container. By default, it is set to no, which means the container will not automatically restart if it stops or encounters an error.
* **command** configuration specifies the command that will be executed when the container starts.

Now, let's discuss each service and some of the important configurations in details.

### Zookeeper

```yaml
zookeeper:
  image: bitnami/zookeeper:3.9.2
  container_name: zookeeper
  ports:
    - "2181:2181"
  environment:
    - ALLOW_ANONYMOUS_LOGIN=yes
  volumes:
    - zookeeper-data:/bitnami/zookeeper
```

The zookeeper service is a centralized coordinator for managing metadata and maintaining the overall state of the Kafka cluster. 
It keeps track of the broker's metadata, such as which brokers are alive, what topics they are handling, and how partitions are distributed across brokers.
Zookeeper is also responsible for electing the leader broker among the available brokers and ensuring that this leadership is maintained or reassigned if the leader broker fails.

For the environment configuration, we set `ALLOW_ANONYMOUS_LOGIN` to yes so that we can connect to the zookeeper service without authentication. 
Note that this is **not recommended** for production environments. In the provided configuration, the volumes demonstrates the usage of Docker volumes (not bind mounts).

### Kafka 

```yaml
kafka:
  image: bitnami/kafka:3.5.2
  container_name: kafka
  ports:
    - "29092:29092"
  environment:
    - ALLOW_PLAINTEXT_LISTENER=yes
    - KAFKA_ENABLE_KRAFT=no
    - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181
    - KAFKA_CFG_LISTENERS=INTERNAL://:9092,EXTERNAL://:29092
    - KAFKA_CFG_ADVERTISED_LISTENERS=INTERNAL://kafka:9092,EXTERNAL://localhost:29092
    - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT
    - KAFKA_INTER_BROKER_LISTENER_NAME=INTERNAL

  volumes:
    - kafka-data:/bitnami/kafka
  depends_on:
    - zookeeper
  restart: always
```

* `ALLOW_PLAINTEXT_LISTENER=yes`

  This allows Kafka to accept connections over a plaintext (unencrypted) protocol. By default, Kafka might require secure connections, but setting this variable to "yes" allows plaintext communication.
  While enabling plaintext listeners can be convenient for local development or testing, it's not recommended for production environments due to the lack of encryption. For production, use secure communication protocols like SSL/TLS.

* `KAFKA_ENABLE_KRAFT=no`
  
  KRaft (Kafka Raft Metadata Mode) is a new way of managing metadata without Zookeeper. Setting this to "no" disables KRaft, making Kafka rely on Zookeeper.
  
* `KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181`

  This variable specifies the hostname and port of the Zookeeper server. Since we are using Docker Compose, we can use the service name zookeeper as the hostname and the default Zookeeper port 2181.

We also need to configure two listeners, one for internal client (other services within the Docker network) and another one for external client (clients outside the Docker network, 
i.e. the host machine). We will name the listener for the internal client as INTERNAL, and the listener for the external client as EXTERNAL. 
These listeners are defined using the following environment configurations:

* `KAFKA_CFG_LISTENERS=INTERNAL://:9092,EXTERNAL://:29092`

  This sets up Kafka listeners on two different interfaces: one internal and one external. INTERNAL://:9092 listens on port 9092 for internal traffic, and EXTERNAL://:29092 listens on port 29092 for external traffic.
  Here we don’t specify any hostname or IP address for both listeners, which means Kafka will listen on all network interfaces within the specified port. 
  Use different listeners for internal and external traffic to separate traffic flow. Consider using secure protocols (e.g., SSL) for the external listener to protect data in transit.

* `KAFKA_CFG_ADVERTISED_LISTENERS=INTERNAL://kafka:9092,EXTERNAL://localhost:29092`

  These are the addresses Kafka advertises to clients for connecting. Internal clients should connect to kafka:9092, while external clients connect to localhost:29092.

* `KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT`

  The security protocol used for each listener. In our case, we are using the PLAINTEXT protocol for both listeners, indicating that no authentication is required.

* `KAFKA_INTER_BROKER_LISTENER_NAME=INTERNAL`

  The name of the listener used for communication between brokers. Typically the listener for the internal client is used for inter-broker communication.

For the ports configuration, we need to expose the external listener port 29092 to the host machine so that we can connect to the kafka service from the host machine.

Since the kafka service depends on the zookeeper service, we specify zookeeper in the `depends_on` configuration to ensure that the zookeeper service is started before the kafka service. 
As of the authors' experiences, there are several occurences where kafka service stopped unexpectedly, so we should set restart configuration to **always** to ensure that the kafka service will be restarted automatically if it stops or encounters an error.

### Spark

```yaml
spark:
  image: bitnami/spark:3.5.2
  container_name: spark
  environment:
    - SPARK_MODE=master
  ports:
    - "8080:8080"
    - "4040:4040"
  volumes:
    - ./spark_script:/spark_script
    - ./spark-defaults.conf:/opt/bitnami/spark/conf/spark-defaults.conf
  depends_on:
    - zookeeper
    - kafka
    - cassandra
  command: bash -c "python -m pip install py4j==0.10.9.7 && tail -f /dev/null"

spark-worker:
  image: docker.io/bitnami/spark:3.5.2
  container_name: spark-worker
  environment:
    - SPARK_MODE=worker
    - SPARK_MASTER_URL=spark://spark:7077
    - SPARK_WORKER_MEMORY=1G
    - SPARK_WORKER_CORES=1
  ports:
    - "8081:8081"
  volumes:
    - ./spark-defaults.conf:/opt/bitnami/spark/conf/spark-defaults.conf
  depends_on:
    - zookeeper
    - kafka
    - cassandra
  command: bash -c "python -m pip install py4j==0.10.9.7 && tail -f /dev/null"
```
Here the **spark** service is configured as the Spark **master** node and **spark-worker** service is configured as the Spark **worker** node, as indicated by the `SPARK_MODE` under environment configuration. 
Besides SPARK_MODE, we also specify the following environment configurations for the spark-worker service:

* `SPARK_MASTER_URL=spark://spark:7077` – The URL of the Spark master node. Here we use the service name spark as the hostname and the default Spark master port 7077.
* `SPARK_WORKER_MEMORY=1G` – The amount of memory to use for the Spark worker node.
* `SPARK_WORKER_CORES=1` – The number of cores to use for the Spark worker node.

For spark, we expose ports 8080 (Spark master web UI) and 4040 (Spark application web UI). The Spark application web UI shows detailed information about the Spark application’s progress and executed tasks. For spark-worker service, we only expose port 8081, which is the Spark worker web UI.

For both spark and spark-worker services, we mount the `spark-defaults.conf` file into the containers by providing a direct mapping between a directory on the host and a directory inside the container. This file contains the configuration properties for the Spark application. 
We also mount the spark_script directory into the container of spark service, which will be used to store the Python script that we will submit to the Spark application.

We also add a command configuration to both spark and spark-worker services to install the **py4j** library, which is required to run the Python script within the Spark application. 
The `tail -f /dev/null` command is used to keep the container running indefinitely.

<Tip> 
  In real practice, you can enhance task performance by increasing the number of Spark worker nodes or increasing the number of cores and memory for each Spark worker node. 
  However, you need to ensure that your machine has sufficient resources to support the desired configuration.
</Tip>

### Cassandra

```yaml
cassandra:
  image: cassandra:5.0
  container_name: cassandra
  ports:
    - "9042:9042"
  volumes:
    - cassandra-data:/var/lib/cassandra
```
The configurations for cassandra service are pretty straightforward and easy to understand. 
We just need to specify the port (default to 9042) and the usage of Docker volumes for data persistence.

### MySQL 

```yaml
mysql:
  image: mysql:9.0.1
  container_name: mysql
  ports:
    - "3307:3306"
  environment:
    MYSQL_ROOT_PASSWORD: root
  volumes:
    - mysql-data:/var/lib/mysql
```

Notice that the port for mysql service is set to 3307 instead of the default port 3306. This is because I already have another mysql service running on port 3306 on my host machine. If you do not have a mysql service running on your host machine, you can use the default port 3306 instead. 
We also set the `MYSQL_ROOT_PASSWORD` to `root` for simplicity, which will be used later to connect to the MySQL server using the **root** user.

At the end of the `docker-compose.yml` file, we specify all the Docker volume names to ensure that the volume names used in the services’ configurations are recognized properly.

```yaml
volumes:
  zookeeper-data:
  kafka-data:
  cassandra-data:
  mysql-data:
```

## OLTP and OLAP Database Setup
In this section, we will design the OLTP (Online Transaction Processing) database schema and implement it in **Cassandra**. **Cassandra** is a NoSQL database that excels at handling high volumes of writes and reads, making it well-suited for OLTP workloads. 
Its distributed architecture and ability to scale horizontally enable efficient data storage and retrieval for real-time transactional applications.

Additionally, we will design the OLAP (Online Analytical Processing) database schema and implement it in **MySQL**. 
**MySQL** is a widely used relational database management system that excels in handling multidimensional tables, making it well-suited for OLAP workloads. 
Its robust support for complex queries and aggregations makes it an ideal choice for analytical applications.

By leveraging the strengths of Cassandra for OLTP and MySQL for OLAP, we can build a comprehensive data processing pipeline that handles both real-time transactional data and analytical queries effectively.

Before we begin, we need to build and run all of the services defined in the docker-compose.yml file. 
To do so, ensure you have Docker Desktop installed and running on your machine and navigate to the project directory and execute the following command:

```bash
docker compose up -d
```

### OLTP Database Design and Implementation

Let's access the Cassandra container and launch CQL shell by running the following commmand:

```bash
docker exec -it cassandra cqlsh
```

This command will open an interactive session within the Cassandra container, allowing you to execute CQL queries and interact with the database.

Now, we will create a new keyspace named `trading` by executing the following command:

```cql
CREATE KEYSPACE trading WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};
```

Note that the replication class of `SimpleStrategy` and a replication factor of one are only suitable for development purposes. 
In a production environment with multiple data centers, it is essential to use other replication strategies (i.e. NetworkTopologyStrategy) and replication factors (greather than one) to ensure fault tolerance and high availability.

<AccordionGroup>
  <Accordion title="SimpleStrategy">
    This strategy is useful for a single data center and one rack for development and testing environments only. 
    It should never be used in production.
  </Accordion>

  <Accordion title="NetworkTopologyStrategy">
    This strategy is good for production or staging environments. As the name suggests, it’s network topology aware, meaning it understands your servers, server racks, and data centers. 
    This strategy is preferred for most deployments because it’s much easier to expand to multiple data centers when needed.
  </Accordion>
</AccordionGroup>

Next, we will create a new table named `real_time_data` in the `trading` keyspace by executing the following command:

```sql
USE trading;

CREATE TABLE trading.real_time_data (
           ... id INT PRIMARY KEY,
           ... created_at TIMESTAMP,
           ... ticker VARCHAR,
           ... sector TEXT
           ... volume INT,
           ... market_cap INT,
           ... price FLOAT,
           ... );
```

This table will be part of our OLTP database, which will store transactional data (raw stock trading data) for our application. 
This table will have several columns including `id`, `created_at`, `volume`, `market_cap`, `ticker`, `price`, and `sector`. The `id` column will serve as the primary key for the table, ensuring uniqueness for each entry.

To illustrate, here is an example of how the row in the table will look like:

|    id    |           created_at            | ticker  |         sector           | volume | market_cap | price |
|----------|---------------------------------|---------|--------------------------|--------|------------|-------|
|    11    | 2024-08-25 07:04:45.000000+0000 | TMAS.JK | Logistics & Deliveries   | 275674 |   4932000  |  550  |

Note that the timestamps in the `created_at` column are stored in UTC timezone, which is the default format for Cassandra.

### OLAP Database Design and Implementation
Now, we will access the MySQL container and launch the MySQL shell by executing the following command:

```bash
docker exec -it mysql mysql -u root -p
```

You will be prompted to enter the password for the root user. We have set the password to **root** in the `docker-compose.yml` file, so enter root as the password.

After entering the password, you will be logged into the MySQL shell. Now, we will create a new database named `trading` by executing the following command:

```sql
CREATE DATABASE trading;
```

After successfully creating the database, we can now use it to create tables. For this lab, we'll use one dimension table, profile, which serves as our master table to store company profiles. 
The table will have four attributes: `ticker`, `company_name`, `sector`, and `shares`. The ticker acts as the **primary key**. 
Sector will be the column where we aggregate and analyze the data. 
Finally, Shares will be used to calculate the market cap if needed. Please note that the data we’ll populate is partially masked (not using actual values) and is for lab purposes only.

```sql
CREATE TABLE profile (
  ticker VARCHAR PRIMARY KEY,
  company_name TEXT,
  sector TEXT,
  shares INT
  );
```

After successfully creating the table with the corresponding schema, we can then populate the table using this [data](https://github.com/onlyphantom/brillian/blob/main/datasets/idx_company_profile_080824.csv).

Finally, let's add another table named `aggregated_data`. The aggregated_data table will store aggregated volume data in a microbatch fashion. 
It consist of the following attributes: `processing_id`, `processed_at`, `sector`, `total_volume`, and `date`. The processing_id serves as the primary key for this table. 
The processed_at column stores the timestamp when the microbatch is processed. 
The date column stores the date of the closing trade. It also has the sector value which will be the grouping key for this table.
The total_volume column stores the total volume of traded stocks for a given microbatch. 
Since the data is aggregated in microbatches, there can be multiple rows with the same date and sector, but different processing_id, processed_at, and total_volume values.

```sql
CREATE TABLE aggregated_data (
  processing_id INT AUTO_INCREMENT,
  processed_at TIMESTAMP,
  date DATE,
  sector TEXT,
  total_volume INT,
  );
```

In this section, we have demonstrated how to implement an OLTP database using Cassandra and an OLAP database using MySQL. 
By combining the capabilities of both the OLTP and OLAP databases, we can support transactional operations while enabling powerful analytical capabilities for decision-making purposes.

## Data Ingestion and Processing 

Once we are done with our database setup, we are more than ready to dive on how to ingest and process transactional data streams using Kafka and Spark Streaming.

[Kafka](/kafka-redis/kafka) is a distributed streaming platform that excels in handling high-throughput, fault-tolerant, and real-time data streams. It provides publish-subscribe messaging system where data is organized into topics and distributed across multiple partitions. 
Many organizations such as LinkedIn, Netflix, and Uber use Kafka to build real-time data pipelines and streaming applications.

Spark Streaming is a powerful component of the Apache Spark ecosystem that enables scalable, fault-tolerant and (near) real-time processing of streaming data. 
It extends the core capabilities of Apache Spark to handle continuous streams of data in a microbatch fashion, which means that the data is processed and analyzed in small and continuous intervals. 
Spark Streaming can be used to process data streams from various sources such as Kafka, Flume, and Kinesis.

In our data pipeline, we utilize the power of Kafka to efficiently load the raw transactional data into Kafka topics. We will then leverage Spark Streaming to process the data in a microbatch fashion and write the processed data to the OLTP database. 
Simultaneously, the aggregated transactional data will be directed to the OLAP databases, allowing us to perform insightful analytical queries on the data.

By combining the strengths of Kafka, Spark Streaming, and our database infrastructure, we establish a robust and scalable data pipeline that enables (near) real-time data processing, seamless data storage, and insightful analytics.

### Getting Started with Kafka Producer

Let's connect to the Kafka container and launch the Kafka shell by executing the following command:

```bash
docker exec -it kafka bash
```

